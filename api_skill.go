/*
YASM (Yet Another Skill Management) API

This is an example of using OAuth2 Implicit Flow in a specification to describe security to your API.

API version: 0.8.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SkillApiService SkillApi service
type SkillApiService service

type SkillApiApiAddPersonInterestRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillId string
}


func (r SkillApiApiAddPersonInterestRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.AddPersonInterestExecute(r)
}

/*
AddPersonInterest Add an Interest to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param skillId
 @return SkillApiApiAddPersonInterestRequest
*/
func (a *SkillApiService) AddPersonInterest(ctx _context.Context, personId string, skillId string) SkillApiApiAddPersonInterestRequest {
	return SkillApiApiAddPersonInterestRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) AddPersonInterestExecute(r SkillApiApiAddPersonInterestRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.AddPersonInterest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/interests/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiAddPersonProjectSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	projectId string
	skillId string
	level *Level
}

// The Skill Level
func (r SkillApiApiAddPersonProjectSkillRequest) Level(level Level) SkillApiApiAddPersonProjectSkillRequest {
	r.level = &level
	return r
}

func (r SkillApiApiAddPersonProjectSkillRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.AddPersonProjectSkillExecute(r)
}

/*
AddPersonProjectSkill Add Skill to a Project participation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param projectId
 @param skillId
 @return SkillApiApiAddPersonProjectSkillRequest
*/
func (a *SkillApiService) AddPersonProjectSkill(ctx _context.Context, personId string, projectId string, skillId string) SkillApiApiAddPersonProjectSkillRequest {
	return SkillApiApiAddPersonProjectSkillRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		projectId: projectId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) AddPersonProjectSkillExecute(r SkillApiApiAddPersonProjectSkillRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.AddPersonProjectSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/projects/{projectId}/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.level
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiAddPersonSkillExperienceRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillId string
	level *Level
}

func (r SkillApiApiAddPersonSkillExperienceRequest) Level(level Level) SkillApiApiAddPersonSkillExperienceRequest {
	r.level = &level
	return r
}

func (r SkillApiApiAddPersonSkillExperienceRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.AddPersonSkillExperienceExecute(r)
}

/*
AddPersonSkillExperience Add an Skill experience to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param skillId
 @return SkillApiApiAddPersonSkillExperienceRequest
*/
func (a *SkillApiService) AddPersonSkillExperience(ctx _context.Context, personId string, skillId string) SkillApiApiAddPersonSkillExperienceRequest {
	return SkillApiApiAddPersonSkillExperienceRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) AddPersonSkillExperienceExecute(r SkillApiApiAddPersonSkillExperienceRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.AddPersonSkillExperience")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/experiences/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.level
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiAddPersonSkillExperiencesRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillLevelUpdate *[]SkillLevelUpdate
}

func (r SkillApiApiAddPersonSkillExperiencesRequest) SkillLevelUpdate(skillLevelUpdate []SkillLevelUpdate) SkillApiApiAddPersonSkillExperiencesRequest {
	r.skillLevelUpdate = &skillLevelUpdate
	return r
}

func (r SkillApiApiAddPersonSkillExperiencesRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.AddPersonSkillExperiencesExecute(r)
}

/*
AddPersonSkillExperiences Add an Skill experience to a Person (bulk)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @return SkillApiApiAddPersonSkillExperiencesRequest
*/
func (a *SkillApiService) AddPersonSkillExperiences(ctx _context.Context, personId string) SkillApiApiAddPersonSkillExperiencesRequest {
	return SkillApiApiAddPersonSkillExperiencesRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) AddPersonSkillExperiencesExecute(r SkillApiApiAddPersonSkillExperiencesRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.AddPersonSkillExperiences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/experiences"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.skillLevelUpdate == nil {
		return localVarReturnValue, nil, reportError("skillLevelUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.skillLevelUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiAddSkillToCertificationRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	certificationId string
	skillId string
	level *Level
}

func (r SkillApiApiAddSkillToCertificationRequest) Level(level Level) SkillApiApiAddSkillToCertificationRequest {
	r.level = &level
	return r
}

func (r SkillApiApiAddSkillToCertificationRequest) Execute() (CertificationDetails, *_nethttp.Response, error) {
	return r.ApiService.AddSkillToCertificationExecute(r)
}

/*
AddSkillToCertification Method for AddSkillToCertification

Add Skill to Certification

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificationId
 @param skillId
 @return SkillApiApiAddSkillToCertificationRequest
*/
func (a *SkillApiService) AddSkillToCertification(ctx _context.Context, certificationId string, skillId string) SkillApiApiAddSkillToCertificationRequest {
	return SkillApiApiAddSkillToCertificationRequest{
		ApiService: a,
		ctx: ctx,
		certificationId: certificationId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return CertificationDetails
func (a *SkillApiService) AddSkillToCertificationExecute(r SkillApiApiAddSkillToCertificationRequest) (CertificationDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CertificationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.AddSkillToCertification")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certifications/{certificationId}/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"certificationId"+"}", _neturl.PathEscape(parameterToString(r.certificationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.level
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiAddSkillToParentSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skillId string
	parentSkillId string
}


func (r SkillApiApiAddSkillToParentSkillRequest) Execute() (SkillDetails, *_nethttp.Response, error) {
	return r.ApiService.AddSkillToParentSkillExecute(r)
}

/*
AddSkillToParentSkill Attach a Skill to a parent Skill, returns the parent Skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param skillId
 @param parentSkillId
 @return SkillApiApiAddSkillToParentSkillRequest
*/
func (a *SkillApiService) AddSkillToParentSkill(ctx _context.Context, skillId string, parentSkillId string) SkillApiApiAddSkillToParentSkillRequest {
	return SkillApiApiAddSkillToParentSkillRequest{
		ApiService: a,
		ctx: ctx,
		skillId: skillId,
		parentSkillId: parentSkillId,
	}
}

// Execute executes the request
//  @return SkillDetails
func (a *SkillApiService) AddSkillToParentSkillExecute(r SkillApiApiAddSkillToParentSkillRequest) (SkillDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkillDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.AddSkillToParentSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills/{skillId}/parents/{parentSkillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentSkillId"+"}", _neturl.PathEscape(parameterToString(r.parentSkillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiConfirmSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	projectId string
	skillId string
	confirmingPersonId string
}


func (r SkillApiApiConfirmSkillRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.ConfirmSkillExecute(r)
}

/*
ConfirmSkill Confirm Skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param projectId
 @param skillId
 @param confirmingPersonId
 @return SkillApiApiConfirmSkillRequest
*/
func (a *SkillApiService) ConfirmSkill(ctx _context.Context, personId string, projectId string, skillId string, confirmingPersonId string) SkillApiApiConfirmSkillRequest {
	return SkillApiApiConfirmSkillRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		projectId: projectId,
		skillId: skillId,
		confirmingPersonId: confirmingPersonId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) ConfirmSkillExecute(r SkillApiApiConfirmSkillRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.ConfirmSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/projects/{projectId}/skills/{skillId}/confirmation/{confirmingPersonId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"confirmingPersonId"+"}", _neturl.PathEscape(parameterToString(r.confirmingPersonId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiCreateSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skill *Skill
}

func (r SkillApiApiCreateSkillRequest) Skill(skill Skill) SkillApiApiCreateSkillRequest {
	r.skill = &skill
	return r
}

func (r SkillApiApiCreateSkillRequest) Execute() (SkillDetails, *_nethttp.Response, error) {
	return r.ApiService.CreateSkillExecute(r)
}

/*
CreateSkill Create a Skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SkillApiApiCreateSkillRequest
*/
func (a *SkillApiService) CreateSkill(ctx _context.Context) SkillApiApiCreateSkillRequest {
	return SkillApiApiCreateSkillRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SkillDetails
func (a *SkillApiService) CreateSkillExecute(r SkillApiApiCreateSkillRequest) (SkillDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkillDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.CreateSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.skill == nil {
		return localVarReturnValue, nil, reportError("skill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.skill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeleteConfirmationRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	projectId string
	skillId string
	confirmingPersonId string
}


func (r SkillApiApiDeleteConfirmationRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.DeleteConfirmationExecute(r)
}

/*
DeleteConfirmation Remove a confirmation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param projectId
 @param skillId
 @param confirmingPersonId
 @return SkillApiApiDeleteConfirmationRequest
*/
func (a *SkillApiService) DeleteConfirmation(ctx _context.Context, personId string, projectId string, skillId string, confirmingPersonId string) SkillApiApiDeleteConfirmationRequest {
	return SkillApiApiDeleteConfirmationRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		projectId: projectId,
		skillId: skillId,
		confirmingPersonId: confirmingPersonId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) DeleteConfirmationExecute(r SkillApiApiDeleteConfirmationRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeleteConfirmation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/projects/{projectId}/skills/{skillId}/confirmation/{confirmingPersonId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"confirmingPersonId"+"}", _neturl.PathEscape(parameterToString(r.confirmingPersonId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeletePersonInterestRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillId string
}


func (r SkillApiApiDeletePersonInterestRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.DeletePersonInterestExecute(r)
}

/*
DeletePersonInterest Remove an Interest to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param skillId
 @return SkillApiApiDeletePersonInterestRequest
*/
func (a *SkillApiService) DeletePersonInterest(ctx _context.Context, personId string, skillId string) SkillApiApiDeletePersonInterestRequest {
	return SkillApiApiDeletePersonInterestRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) DeletePersonInterestExecute(r SkillApiApiDeletePersonInterestRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeletePersonInterest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/interests/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeletePersonProjectSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	projectId string
	skillId string
}


func (r SkillApiApiDeletePersonProjectSkillRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.DeletePersonProjectSkillExecute(r)
}

/*
DeletePersonProjectSkill Remove a Skill from a Project participation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param projectId
 @param skillId
 @return SkillApiApiDeletePersonProjectSkillRequest
*/
func (a *SkillApiService) DeletePersonProjectSkill(ctx _context.Context, personId string, projectId string, skillId string) SkillApiApiDeletePersonProjectSkillRequest {
	return SkillApiApiDeletePersonProjectSkillRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		projectId: projectId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) DeletePersonProjectSkillExecute(r SkillApiApiDeletePersonProjectSkillRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeletePersonProjectSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/projects/{projectId}/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeletePersonSkillExperienceRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillId string
}


func (r SkillApiApiDeletePersonSkillExperienceRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.DeletePersonSkillExperienceExecute(r)
}

/*
DeletePersonSkillExperience Remove an Skill Experience to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param skillId
 @return SkillApiApiDeletePersonSkillExperienceRequest
*/
func (a *SkillApiService) DeletePersonSkillExperience(ctx _context.Context, personId string, skillId string) SkillApiApiDeletePersonSkillExperienceRequest {
	return SkillApiApiDeletePersonSkillExperienceRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) DeletePersonSkillExperienceExecute(r SkillApiApiDeletePersonSkillExperienceRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeletePersonSkillExperience")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/experiences/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeletePersonSkillExperiencesRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	requestBody *[]string
}

// A list of skillIds
func (r SkillApiApiDeletePersonSkillExperiencesRequest) RequestBody(requestBody []string) SkillApiApiDeletePersonSkillExperiencesRequest {
	r.requestBody = &requestBody
	return r
}

func (r SkillApiApiDeletePersonSkillExperiencesRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.DeletePersonSkillExperiencesExecute(r)
}

/*
DeletePersonSkillExperiences Remove an Skill Experience to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @return SkillApiApiDeletePersonSkillExperiencesRequest
*/
func (a *SkillApiService) DeletePersonSkillExperiences(ctx _context.Context, personId string) SkillApiApiDeletePersonSkillExperiencesRequest {
	return SkillApiApiDeletePersonSkillExperiencesRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) DeletePersonSkillExperiencesExecute(r SkillApiApiDeletePersonSkillExperiencesRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeletePersonSkillExperiences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/experiences"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeleteSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skillId string
}


func (r SkillApiApiDeleteSkillRequest) Execute() (Status, *_nethttp.Response, error) {
	return r.ApiService.DeleteSkillExecute(r)
}

/*
DeleteSkill Delete a Skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param skillId
 @return SkillApiApiDeleteSkillRequest
*/
func (a *SkillApiService) DeleteSkill(ctx _context.Context, skillId string) SkillApiApiDeleteSkillRequest {
	return SkillApiApiDeleteSkillRequest{
		ApiService: a,
		ctx: ctx,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return Status
func (a *SkillApiService) DeleteSkillExecute(r SkillApiApiDeleteSkillRequest) (Status, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeleteSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiDeleteSkillFromCertificationRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	certificationId string
	skillId string
}


func (r SkillApiApiDeleteSkillFromCertificationRequest) Execute() (CertificationDetails, *_nethttp.Response, error) {
	return r.ApiService.DeleteSkillFromCertificationExecute(r)
}

/*
DeleteSkillFromCertification Method for DeleteSkillFromCertification

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificationId
 @param skillId
 @return SkillApiApiDeleteSkillFromCertificationRequest
*/
func (a *SkillApiService) DeleteSkillFromCertification(ctx _context.Context, certificationId string, skillId string) SkillApiApiDeleteSkillFromCertificationRequest {
	return SkillApiApiDeleteSkillFromCertificationRequest{
		ApiService: a,
		ctx: ctx,
		certificationId: certificationId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return CertificationDetails
func (a *SkillApiService) DeleteSkillFromCertificationExecute(r SkillApiApiDeleteSkillFromCertificationRequest) (CertificationDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CertificationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.DeleteSkillFromCertification")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certifications/{certificationId}/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"certificationId"+"}", _neturl.PathEscape(parameterToString(r.certificationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiGetSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skillId string
}


func (r SkillApiApiGetSkillRequest) Execute() (SkillDetails, *_nethttp.Response, error) {
	return r.ApiService.GetSkillExecute(r)
}

/*
GetSkill Get details for a single skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param skillId
 @return SkillApiApiGetSkillRequest
*/
func (a *SkillApiService) GetSkill(ctx _context.Context, skillId string) SkillApiApiGetSkillRequest {
	return SkillApiApiGetSkillRequest{
		ApiService: a,
		ctx: ctx,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return SkillDetails
func (a *SkillApiService) GetSkillExecute(r SkillApiApiGetSkillRequest) (SkillDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkillDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.GetSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiGetSkillParentsRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skillId string
	skip *int32
	limit *int32
}

func (r SkillApiApiGetSkillParentsRequest) Skip(skip int32) SkillApiApiGetSkillParentsRequest {
	r.skip = &skip
	return r
}
func (r SkillApiApiGetSkillParentsRequest) Limit(limit int32) SkillApiApiGetSkillParentsRequest {
	r.limit = &limit
	return r
}

func (r SkillApiApiGetSkillParentsRequest) Execute() (PagedSkills, *_nethttp.Response, error) {
	return r.ApiService.GetSkillParentsExecute(r)
}

/*
GetSkillParents Get ghe list of parents for a skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param skillId
 @return SkillApiApiGetSkillParentsRequest
*/
func (a *SkillApiService) GetSkillParents(ctx _context.Context, skillId string) SkillApiApiGetSkillParentsRequest {
	return SkillApiApiGetSkillParentsRequest{
		ApiService: a,
		ctx: ctx,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PagedSkills
func (a *SkillApiService) GetSkillParentsExecute(r SkillApiApiGetSkillParentsRequest) (PagedSkills, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PagedSkills
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.GetSkillParents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills/{skillId}/parents"
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiGetSkillsRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	types *string
	suggestions *string
	skip *int32
	limit *int32
}

// Gives you either all skills, only the root kills or those which are defining kinds
func (r SkillApiApiGetSkillsRequest) Types(types string) SkillApiApiGetSkillsRequest {
	r.types = &types
	return r
}
// Optionally filter skills based on suggestion
func (r SkillApiApiGetSkillsRequest) Suggestions(suggestions string) SkillApiApiGetSkillsRequest {
	r.suggestions = &suggestions
	return r
}
func (r SkillApiApiGetSkillsRequest) Skip(skip int32) SkillApiApiGetSkillsRequest {
	r.skip = &skip
	return r
}
func (r SkillApiApiGetSkillsRequest) Limit(limit int32) SkillApiApiGetSkillsRequest {
	r.limit = &limit
	return r
}

func (r SkillApiApiGetSkillsRequest) Execute() (PagedSkills, *_nethttp.Response, error) {
	return r.ApiService.GetSkillsExecute(r)
}

/*
GetSkills Get a list of all skills, optionally only root, optionally only kinds

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SkillApiApiGetSkillsRequest
*/
func (a *SkillApiService) GetSkills(ctx _context.Context) SkillApiApiGetSkillsRequest {
	return SkillApiApiGetSkillsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagedSkills
func (a *SkillApiService) GetSkillsExecute(r SkillApiApiGetSkillsRequest) (PagedSkills, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PagedSkills
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.GetSkills")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	}
	if r.suggestions != nil {
		localVarQueryParams.Add("suggestions", parameterToString(*r.suggestions, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiRemoveSkillFromParentSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skillId string
	parentSkillId string
}


func (r SkillApiApiRemoveSkillFromParentSkillRequest) Execute() (SkillDetails, *_nethttp.Response, error) {
	return r.ApiService.RemoveSkillFromParentSkillExecute(r)
}

/*
RemoveSkillFromParentSkill Detaches a Skill from parent Skill, return the parent Skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param skillId
 @param parentSkillId
 @return SkillApiApiRemoveSkillFromParentSkillRequest
*/
func (a *SkillApiService) RemoveSkillFromParentSkill(ctx _context.Context, skillId string, parentSkillId string) SkillApiApiRemoveSkillFromParentSkillRequest {
	return SkillApiApiRemoveSkillFromParentSkillRequest{
		ApiService: a,
		ctx: ctx,
		skillId: skillId,
		parentSkillId: parentSkillId,
	}
}

// Execute executes the request
//  @return SkillDetails
func (a *SkillApiService) RemoveSkillFromParentSkillExecute(r SkillApiApiRemoveSkillFromParentSkillRequest) (SkillDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkillDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.RemoveSkillFromParentSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills/{skillId}/parents/{parentSkillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentSkillId"+"}", _neturl.PathEscape(parameterToString(r.parentSkillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiUpdatePersonProjectSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	projectId string
	skillId string
	level *Level
}

// The Skill Level
func (r SkillApiApiUpdatePersonProjectSkillRequest) Level(level Level) SkillApiApiUpdatePersonProjectSkillRequest {
	r.level = &level
	return r
}

func (r SkillApiApiUpdatePersonProjectSkillRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.UpdatePersonProjectSkillExecute(r)
}

/*
UpdatePersonProjectSkill Update the level of a Skill in a Project participation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param projectId
 @param skillId
 @return SkillApiApiUpdatePersonProjectSkillRequest
*/
func (a *SkillApiService) UpdatePersonProjectSkill(ctx _context.Context, personId string, projectId string, skillId string) SkillApiApiUpdatePersonProjectSkillRequest {
	return SkillApiApiUpdatePersonProjectSkillRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		projectId: projectId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) UpdatePersonProjectSkillExecute(r SkillApiApiUpdatePersonProjectSkillRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.UpdatePersonProjectSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/projects/{projectId}/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.level
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiUpdatePersonSkillExperienceRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillId string
	level *Level
}

func (r SkillApiApiUpdatePersonSkillExperienceRequest) Level(level Level) SkillApiApiUpdatePersonSkillExperienceRequest {
	r.level = &level
	return r
}

func (r SkillApiApiUpdatePersonSkillExperienceRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.UpdatePersonSkillExperienceExecute(r)
}

/*
UpdatePersonSkillExperience Edit an Skill experience to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @param skillId
 @return SkillApiApiUpdatePersonSkillExperienceRequest
*/
func (a *SkillApiService) UpdatePersonSkillExperience(ctx _context.Context, personId string, skillId string) SkillApiApiUpdatePersonSkillExperienceRequest {
	return SkillApiApiUpdatePersonSkillExperienceRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) UpdatePersonSkillExperienceExecute(r SkillApiApiUpdatePersonSkillExperienceRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.UpdatePersonSkillExperience")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/experiences/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.level
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiUpdatePersonSkillExperiencesRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	personId string
	skillLevelUpdate *[]SkillLevelUpdate
}

func (r SkillApiApiUpdatePersonSkillExperiencesRequest) SkillLevelUpdate(skillLevelUpdate []SkillLevelUpdate) SkillApiApiUpdatePersonSkillExperiencesRequest {
	r.skillLevelUpdate = &skillLevelUpdate
	return r
}

func (r SkillApiApiUpdatePersonSkillExperiencesRequest) Execute() (PersonDetails, *_nethttp.Response, error) {
	return r.ApiService.UpdatePersonSkillExperiencesExecute(r)
}

/*
UpdatePersonSkillExperiences Edit an Skill experience to a Person

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param personId
 @return SkillApiApiUpdatePersonSkillExperiencesRequest
*/
func (a *SkillApiService) UpdatePersonSkillExperiences(ctx _context.Context, personId string) SkillApiApiUpdatePersonSkillExperiencesRequest {
	return SkillApiApiUpdatePersonSkillExperiencesRequest{
		ApiService: a,
		ctx: ctx,
		personId: personId,
	}
}

// Execute executes the request
//  @return PersonDetails
func (a *SkillApiService) UpdatePersonSkillExperiencesExecute(r SkillApiApiUpdatePersonSkillExperiencesRequest) (PersonDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersonDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.UpdatePersonSkillExperiences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/persons/{personId}/experiences"
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", _neturl.PathEscape(parameterToString(r.personId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.skillLevelUpdate == nil {
		return localVarReturnValue, nil, reportError("skillLevelUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.skillLevelUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiUpdateSkillRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	skillId string
	skill *Skill
}

func (r SkillApiApiUpdateSkillRequest) Skill(skill Skill) SkillApiApiUpdateSkillRequest {
	r.skill = &skill
	return r
}

func (r SkillApiApiUpdateSkillRequest) Execute() (SkillDetails, *_nethttp.Response, error) {
	return r.ApiService.UpdateSkillExecute(r)
}

/*
UpdateSkill Update a Skill

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param skillId
 @return SkillApiApiUpdateSkillRequest
*/
func (a *SkillApiService) UpdateSkill(ctx _context.Context, skillId string) SkillApiApiUpdateSkillRequest {
	return SkillApiApiUpdateSkillRequest{
		ApiService: a,
		ctx: ctx,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return SkillDetails
func (a *SkillApiService) UpdateSkillExecute(r SkillApiApiUpdateSkillRequest) (SkillDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SkillDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.UpdateSkill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.skill == nil {
		return localVarReturnValue, nil, reportError("skill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.skill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkillApiApiUpdateSkillInCertificationRequest struct {
	ctx _context.Context
	ApiService *SkillApiService
	certificationId string
	skillId string
	level *Level
}

func (r SkillApiApiUpdateSkillInCertificationRequest) Level(level Level) SkillApiApiUpdateSkillInCertificationRequest {
	r.level = &level
	return r
}

func (r SkillApiApiUpdateSkillInCertificationRequest) Execute() (CertificationDetails, *_nethttp.Response, error) {
	return r.ApiService.UpdateSkillInCertificationExecute(r)
}

/*
UpdateSkillInCertification Method for UpdateSkillInCertification

Update Skill in Certification

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificationId
 @param skillId
 @return SkillApiApiUpdateSkillInCertificationRequest
*/
func (a *SkillApiService) UpdateSkillInCertification(ctx _context.Context, certificationId string, skillId string) SkillApiApiUpdateSkillInCertificationRequest {
	return SkillApiApiUpdateSkillInCertificationRequest{
		ApiService: a,
		ctx: ctx,
		certificationId: certificationId,
		skillId: skillId,
	}
}

// Execute executes the request
//  @return CertificationDetails
func (a *SkillApiService) UpdateSkillInCertificationExecute(r SkillApiApiUpdateSkillInCertificationRequest) (CertificationDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CertificationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SkillApiService.UpdateSkillInCertification")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certifications/{certificationId}/skills/{skillId}"
	localVarPath = strings.Replace(localVarPath, "{"+"certificationId"+"}", _neturl.PathEscape(parameterToString(r.certificationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"skillId"+"}", _neturl.PathEscape(parameterToString(r.skillId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.level == nil {
		return localVarReturnValue, nil, reportError("level is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.level
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
